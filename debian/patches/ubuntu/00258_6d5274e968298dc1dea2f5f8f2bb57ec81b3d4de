commit 2fd8cd838b8d3d4fd2d34a5ccc2d02539c1accc8
Author: Yang Bo <yangbo@deepin.com>
Date:   Thu Mar 22 09:17:17 2018 +0800

    UBUNTU: SAUCE: overlayfs: Propogate nosuid from lower and upper mounts
    
    An overlayfs mount using an upper or lower directory from a
    nosuid filesystem bypasses this restriction. Change this so
    that if any lower or upper directory is nosuid at mount time the
    overlayfs superblock is marked nosuid. This requires some
    additions at the vfs level since nosuid currently only applies to
    mounts, so a SB_I_NOSUID flag is added along with a helper
    function to check a path for nosuid in both the mount and the
    superblock.
    
    BugLink: http://bugs.launchpad.net/bugs/1534961
    BugLink: http://bugs.launchpad.net/bugs/1535150
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Signed-off-by: Yang Bo <yangbo@deepin.com>
    Signed-off-by: Yang Bo <yangbo@deepin.com>

diff --git a/fs/exec.c b/fs/exec.c
index 6b5c8bd89..3ae4b6a26 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -113,6 +113,13 @@ bool path_noexec(const struct path *path)
 }
 EXPORT_SYMBOL_GPL(path_noexec);
 
+bool path_nosuid(const struct path *path)
+{
+	return !mnt_may_suid(path->mnt) ||
+	       (path->mnt->mnt_sb->s_iflags & SB_I_NOSUID);
+}
+EXPORT_SYMBOL(path_nosuid);
+
 #ifdef CONFIG_USELIB
 /*
  * Note that a shared library must be both readable and executable due to
@@ -1521,7 +1528,7 @@ static void bprm_fill_uid(struct linux_binprm *bprm)
 	bprm->cred->euid = current_euid();
 	bprm->cred->egid = current_egid();
 
-	if (!mnt_may_suid(bprm->file->f_path.mnt))
+	if (path_nosuid(&bprm->file->f_path))
 		return;
 
 	if (task_no_new_privs(current))
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 79e430b6b..7b35e2ddc 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -974,6 +974,9 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 
 		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
 
+		if (ufs->upper_mnt->mnt_flags & MNT_NOSUID)
+			sb->s_iflags |= SB_I_NOSUID;
+
 		ufs->workdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 						  OVL_WORKDIR_NAME, false);
 		/*
@@ -1045,6 +1048,9 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 		 */
 		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 
+		if (mnt->mnt_flags & MNT_NOSUID)
+			sb->s_iflags |= SB_I_NOSUID;
+
 		ufs->lower_mnt[ufs->numlower] = mnt;
 		ufs->numlower++;
 
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 90b5293b7..6191abf2f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1317,6 +1317,7 @@ extern int send_sigurg(struct fown_struct *fown);
 
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
+#define SB_I_NOSUID	0x00000020	/* Ignore suid on this fs */
 
 /* Possible states of 'frozen' field */
 enum {
@@ -3400,6 +3401,7 @@ static inline bool dir_relax_shared(struct inode *inode)
 }
 
 extern bool path_noexec(const struct path *path);
+extern bool path_nosuid(const struct path *path);
 extern void inode_nohighmem(struct inode *inode);
 
 #endif /* _LINUX_FS_H */
diff --git a/security/commoncap.c b/security/commoncap.c
index b9754304a..7fd4848fb 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -660,7 +660,7 @@ static int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_c
 	if (!file_caps_enabled)
 		return 0;
 
-	if (!mnt_may_suid(bprm->file->f_path.mnt))
+	if (path_nosuid(&bprm->file->f_path))
 		return 0;
 
 	/*
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 44b329748..8d9a9556a 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -2271,7 +2271,7 @@ static int check_nnp_nosuid(const struct linux_binprm *bprm,
 			    const struct task_security_struct *new_tsec)
 {
 	int nnp = (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS);
-	int nosuid = !mnt_may_suid(bprm->file->f_path.mnt);
+	int nosuid = path_nosuid(&bprm->file->f_path);
 	int rc;
 	u32 av;
 
