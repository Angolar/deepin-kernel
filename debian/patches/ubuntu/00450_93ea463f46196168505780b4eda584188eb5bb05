commit 93ea463f46196168505780b4eda584188eb5bb05
Author: Stefan Bader <stefan.bader@canonical.com>
Date:   Thu Sep 29 18:19:25 2016 +0200

    UBUNTU: SAUCE: nbd: Only delay uevent until connected
    
    Just a hack until it is understood what actually generates the
    uevent which also triggers a partition scan.
    
    Commit 37091fdd831f28a6509008542174ed324dd645bc (in 4.8-rc1)
      nbd: Create size change events for userspace
    
    tries to do the right thing and add a change event at the right
    time, but doing so made things actually worse.
    
    The only thing which this patch changes is that i_size and the
    capacity are touched multiple times. Both actions do not look
    like they could cause a change event being triggered in any way.
    Still it does happen and whatever is doing this, it also causes
    a partition scan.
    
    So without this change when connecting a file image with qemu-nbd
    there was only one change event and no partitions added. However
    in some rare cases there were two change events on the main nbd
    device and partitions were added.
    
    One thought I had was maybe something like inotify notes the
    change to bdev->bd_inode->i_size and triggers the partition
    scan when the capacity is already >0. But only changing the
    order but not update all variables whenever any of the related
    ioctl calls is made is not working. This somehow leave only the
    longer time the changes are exposed until nbd sends its own
    change event as some sort of explanation.
    
    BugLink: http://bugs.launchpad.net/bugs/1628336
    
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c
index aa462f7..5ac7368 100644
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@ -131,8 +131,6 @@ static void nbd_size_update(struct nbd_device *nbd, struct block_device *bdev)
 	if (!nbd_is_connected(nbd))
 		return;
 
-	bdev->bd_inode->i_size = nbd->bytesize;
-	set_capacity(nbd->disk, nbd->bytesize >> 9);
 	kobject_uevent(&nbd_to_dev(nbd)->kobj, KOBJ_CHANGE);
 }
 
@@ -148,6 +146,8 @@ static int nbd_size_set(struct nbd_device *nbd, struct block_device *bdev,
 	nbd->blksize = blocksize;
 	nbd->bytesize = blocksize * nr_blocks;
 
+	bdev->bd_inode->i_size = nbd->bytesize;
+	set_capacity(nbd->disk, nbd->bytesize >> 9);
 	nbd_size_update(nbd, bdev);
 
 	return 0;
